/* Copyright (C) 2016-2019 INRA
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef ORG_VLEPROJECT_BARYONYX_SOLVER_CORE_OUT
#define ORG_VLEPROJECT_BARYONYX_SOLVER_CORE_OUT

#include <baryonyx/core>

namespace baryonyx {

/**
 * @brief Write baryonyx::result into a `dot sol` format.
 * @details The `dot sol` format use the same comment and variable names as the
 *     `dot lp` format. All meta data, constraint remaining, duration are
 *     stored into comment in `dot sol` format. Only variable affectation are
 *     full useful.
 *
 * @param os [out] class output std::ostream.
 * @param result [in] the baryonyx::result to write.
 */
template<typename OuputStream>
inline OuputStream&
operator<<(OuputStream& os, const result& result)
{
    std::size_t i, e;

    os << R"(\ solver................: )" << result.method << '\n'
       << R"(\ constraints...........: )" << result.constraints << '\n'
       << R"(\ variables.............: )" << result.variables << '\n'
       << R"(\ duration..............: )" << result.duration << "s\n"
       << R"(\ loop..................: )" << result.loop << '\n'
       << R"(\ status................: )";

    switch (result.status) {
    case result_status::internal_error:
        os << "internal error reported\n";
        break;
    case result_status::uninitialized:
        os << "uninitialized\n";
        break;
    case result_status::success:
        os << "solution found\n";

        if (result.solutions.empty()) // Baryonyx ensures solutions are not
            break;                    // empty.

        os << R"(\ value.................: )" << result.solutions.back().value
           << '\n'
           << R"(\ other value...........: )";

        for (const auto& elem : result.solutions)
            os << elem.value << ' ';
        os << '\n';

        os << "\\ variables.............: \n";

        for (i = 0, e = result.affected_vars.names.size(); i != e; ++i) {
            os << result.affected_vars.names[i] << '='
               << (result.affected_vars.values[i] ? 1 : 0) << '\n';
        }

        for (i = 0, e = result.variable_name.size(); i != e; ++i) {
            os << result.variable_name[i] << '='
               << (result.solutions.back().variables[i] ? 1 : 0) << '\n';
        }
        break;
    case result_status::time_limit_reached:
        os << "time limit reached\n"
           << R"(\ remaining constraints.: )" << result.remaining_constraints
           << '\n';
        break;
    case result_status::kappa_max_reached:
        os << "kappa max reached\n"
           << R"(\ remaining constraints.: )" << result.remaining_constraints
           << '\n';
        break;
    case result_status::limit_reached:
        os << "limit reached\n"
           << R"(\ remaining constraints.: )" << result.remaining_constraints
           << '\n';
        break;
    }

    return os;
}

inline std::string_view
pre_constraint_order_to_string(
  solver_parameters::pre_constraint_order type) noexcept
{
    using underlying_type = typename std::underlying_type<
      solver_parameters::pre_constraint_order>::type;

    static std::string_view ret[] = { "none",
                                      "memory",
                                      "less-greater-equal",
                                      "less-equal-greater",
                                      "greater-less-equal",
                                      "greater-equal-less",
                                      "equal-less-greater",
                                      "equal-greater-less",
                                      "p1",
                                      "p2",
                                      "p3",
                                      "p4" };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
constraint_order_to_string(solver_parameters::constraint_order type) noexcept
{
    using underlying_type =
      typename std::underlying_type<solver_parameters::constraint_order>::type;

    static std::string_view ret[] = { "none",
                                      "reversing",
                                      "random-sorting",
                                      "infeasibility-decr",
                                      "infeasibility-incr",
                                      "lagrangian-decr",
                                      "lagrangian-incr",
                                      "pi-sign-change",
                                      "cycle" };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
floating_point_type_to_string(
  solver_parameters::floating_point_type type) noexcept
{
    using underlying_type = typename std::underlying_type<
      solver_parameters::floating_point_type>::type;

    static std::string_view ret[] = {
        "float",
        "double",
        "longdouble",
    };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
init_policy_type_to_string(solver_parameters::init_policy_type type) noexcept
{
    using underlying_type =
      typename std::underlying_type<solver_parameters::init_policy_type>::type;

    static std::string_view ret[] = {
        "bastert", "pessimistic-solve", "optimistic-solve", "cycle"
    };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
cost_norm_type_to_string(solver_parameters::cost_norm_type type) noexcept
{
    using underlying_type =
      typename std::underlying_type<solver_parameters::cost_norm_type>::type;

    static std::string_view ret[] = { "none", "random", "l1", "l2", "loo" };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
mode_type_to_string(solver_parameters::mode_type type) noexcept
{
    using underlying_type =
      typename std::underlying_type<solver_parameters::mode_type>::type;

    static std::string_view ret[] = {
        "disabled", "manual",           "nlopt",
        "branch",   "manul-and-branch", "nlopt-and-branch"
    };

    if (static_cast<underlying_type>(type) &
        static_cast<underlying_type>(solver_parameters::mode_type::branch)) {
        if (static_cast<underlying_type>(type) &
            static_cast<underlying_type>(solver_parameters::mode_type::manual))
            return ret[4];
        else if (static_cast<underlying_type>(type) &
                 static_cast<underlying_type>(
                   solver_parameters::mode_type::nlopt))
            return ret[5];
        else
            return ret[3];
    } else {
        if (static_cast<underlying_type>(type) &
            static_cast<underlying_type>(solver_parameters::mode_type::manual))
            return ret[1];
        if (static_cast<underlying_type>(type) &
            static_cast<underlying_type>(solver_parameters::mode_type::nlopt))
            return ret[2];
    }

    return ret[0];
}

inline std::string_view
observer_type_to_string(solver_parameters::observer_type type) noexcept
{
    using underlying_type =
      typename std::underlying_type<solver_parameters::observer_type>::type;

    static std::string_view ret[] = { "none", "pnm", "file" };

    return ret[static_cast<underlying_type>(type)];
}

inline std::string_view
storage_type_to_string(solver_parameters::storage_type type) noexcept
{
    using underlying_type = typename std::underlying_type<
      solver_parameters::solver_parameters::storage_type>::type;

    static std::string_view ret[] = { "one", "bound", "five" };

    return ret[static_cast<underlying_type>(type)];
}

} // namespace baryonyx

#endif
